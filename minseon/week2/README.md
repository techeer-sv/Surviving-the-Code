# Week 2

Created on 2025-08-18

## 📚 백준 문제 풀이

이번 주차에는 **그리디 알고리즘**과 **구현** 문제들을 풀었습니다.

---

## 🚀 문제 1: A → B (16953번)

### 📖 문제 설명

정수 A를 B로 바꾸는 최소 연산 횟수를 구하는 문제입니다.

**연산 규칙:**

- 2를 곱한다
- 1을 수의 가장 오른쪽에 추가한다

**입력:** A, B (1 ≤ A < B ≤ 10^9)
**출력:** A를 B로 바꾸는 최소 연산 횟수 (불가능하면 -1)

### 💡 풀이 아이디어

**역방향 접근법**을 사용했습니다:

- B에서 A로 역추적하는 방식
- B가 짝수면 2로 나누기
- B의 끝자리가 1이면 10으로 나누고 1 빼기
- 더 이상 연산이 불가능하면 -1 반환

### 🔍 핵심 로직

```java
while (last > start) {
    if (last % 2 == 0) {
        last = last / 2;        // 2로 나누기
    } else if (last % 10 == 1) {
        last = (last - 1) / 10; // 끝자리 1 제거
    } else {
        break;                   // 더 이상 연산 불가능
    }
    count++;
}
```

### ⏰ 시간복잡도

- **시간복잡도:** O(log B)
- **공간복잡도:** O(1)
- B를 2로 나누거나 10으로 나누는 연산이므로 로그 시간에 해결

### 🧪 테스트 케이스

- **기본 케이스:** 2 → 162 (8회), 4 → 42 (5회)
- **경계값:** 1 → 1 (1회), 0 → 10
- **변환 불가능:** 2 → 3 (-1), 2 → 7 (-1)
- **큰 수:** 1 → 1000000000

---

## 🚀 문제 2: 주유소 (13305번)

### 📖 문제 설명

N개 도시를 연결하는 도로가 있고, 각 도시마다 주유소가 있어서 기름을 넣을 수 있습니다.
왼쪽 도시에서 오른쪽 도시로 가는 최소 비용을 구하는 문제입니다.

**입력:**

- N (2 ≤ N ≤ 100,000)
- 도시 간 거리 배열
- 각 도시의 주유 가격 배열

**출력:** 최소 주유 비용

### 💡 풀이 아이디어

**그리디 알고리즘**을 사용했습니다:

- 현재까지의 최소 가격으로 기름을 넣기
- 더 싼 가격이 나오면 최소 가격 갱신
- 각 구간마다 최소 가격 × 거리로 비용 계산

### 🔍 핵심 로직

```java
long leastCost = cost[0];  // 첫 번째 도시 가격으로 시작
long sum = 0;
for (int i = 0; i < dist.length; i++) {
    if (leastCost > cost[i]) {
        leastCost = cost[i];    // 더 싼 가격 발견시 갱신
    }
    sum += leastCost * dist[i]; // 현재 최소 가격으로 주유
}
```

### ⏰ 시간복잡도

- **시간복잡도:** O(N)
- **공간복잡도:** O(N)
- 도시 수만큼 한 번씩 순회하므로 선형 시간

### 🧪 테스트 케이스

- **기본 케이스:** 4개 도시, 거리[2,3,1], 가격[5,2,4,1] → 18
- **최적화:** 6개 도시, 거리[2,2,2,2,2], 가격[1,2,3,4,5,6] → 10
- **경계값:** 2개 도시, 거리[1], 가격[1,1] → 1
- **큰 수:** 거리[1000000], 가격[1000000,999999,1000000]

---

## 🚀 문제 3: 피로도 (22864번)

### 📖 문제 설명

하루 24시간 동안 일할 수 있는 최대 일량을 구하는 문제입니다.

**피로도 시스템:**

- 일할 때: 피로도 +A, 일량 +B
- 쉴 때: 피로도 -C (0 이하로는 내려가지 않음)
- 피로도가 M을 초과하면 일할 수 없음

**입력:** A, B, C, M (1 ≤ A, B, C, M ≤ 1,000,000)
**출력:** 24시간 동안 할 수 있는 최대 일량

### 💡 풀이 아이디어

**시뮬레이션**을 사용했습니다:

- 24시간을 1시간씩 시뮬레이션
- 각 시간마다 피로도 체크하여 일할지 쉴지 결정
- 피로도가 M 이하면 일하기, 초과하면 쉬기

### 🔍 핵심 로직

```java
for (int hour = 1; hour <= 24; hour++) {
    if (tired + a <= m) {           // 피로도가 허용 범위
        work += b;                   // 일하기
        tired += a;                  // 피로도 증가
    } else {
        tired = Math.max(0, tired - c); // 쉬기 (피로도 감소)
    }
}
```

### ⏰ 시간복잡도

- **시간복잡도:** O(1)
- **공간복잡도:** O(1)
- 24시간은 고정값이므로 상수 시간

### 🧪 테스트 케이스

- **기본 케이스:** a=5, b=3, c=2, m=10 → 24
- **최적화:** a=3, b=2, c=1, m=5 → 48
- **경계값:** a=1, b=1, c=1, m=1 → 24
- **큰 수:** a=100, b=50, c=25, m=200

---

## 🎯 학습 포인트

### 1. **그리디 알고리즘**

- **16953번:** 역방향 접근으로 최적해 찾기
- **13305번:** 현재까지의 최적값을 유지하며 진행

### 2. **구현 문제**

- **22864번:** 문제 조건을 정확히 파악하고 시뮬레이션

### 3. **시간복잡도 분석**

- **16953번:** O(log B) - 로그 시간
- **13305번:** O(N) - 선형 시간
- **22864번:** O(1) - 상수 시간

### 4. **코드 최적화**

- 불필요한 반복문 제거
- 적절한 자료형 선택 (long 사용)
- 경계값 처리

---

## 🧪 테스트 실행 방법

각 문제의 테스트 코드는 `Main.java` 파일에 포함되어 있습니다.

```bash
# 컴파일
javac Main.java

# 실행 (기본 입력)
java Main

# 테스트 실행 (테스트 케이스들)
# Main.java의 runTests() 메서드 호출
```

---

## 📊 문제별 난이도 및 성공률

| 문제  | 난이도      | 알고리즘         | 성공 여부 |
| ----- | ----------- | ---------------- | --------- |
| 16953 | 🟡 Silver 2 | 그리디, 역방향   | ✅        |
| 13305 | 🟡 Silver 4 | 그리디           | ✅        |
| 22864 | 🟡 Silver 4 | 구현, 시뮬레이션 | ✅        |

---

## 🔗 관련 링크

- [백준 16953번 - A → B](https://www.acmicpc.net/problem/16953)
- [백준 13305번 - 주유소](https://www.acmicpc.net/problem/13305)
- [백준 22864번 - 피로도](https://www.acmicpc.net/problem/22864)
