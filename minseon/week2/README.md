# Week 2

Created on 2025-08-29

## 📚 백준 문제 풀이

이번 주차에는 **그리디 알고리즘** 문제들을 풀었습니다.

## 🚀 문제 1: A → B (16953번)

### 📖 문제 설명

정수 A를 B로 바꾸는 최소 연산 횟수를 구하는 문제입니다.

**연산 규칙:**

- 2를 곱한다
- 1을 수의 가장 오른쪽에 추가한다

**입력:** A, B (1 ≤ A < B ≤ 10^9) =>int 범위
**출력:** A를 B로 바꾸는 최소 연산 횟수 (불가능하면 -1)

### 💡 풀이 아이디어

**역방향 접근법**을 사용했습니다:

- => 순 방향(A=>B)로 하면 경우의수가 너무 많아 지므로 (1)역방향이 가능한 경우 (2)불가능한 경우를 생각하고<br>
  역방향이 가능하다면 연산 규칙에 따라 \* or 1추가 를 역방향으로 개산, 불가능 한 경우는 -1 반환.

- B에서 A로 역추적하는 방식
- B가 짝수면 2로 나누기
- B의 끝자리가 1이면 -1 하고 10으로 나누기
- 더 이상 연산이 불가능하면 -1 반환

### 🔍 핵심 로직

```java
while (last > start) {
    if (last % 2 == 0) {
        last = last / 2;        // 2로 나누기
    } else if (last % 10 == 1) {
        last = (last - 1) / 10; // 끝자리 1 제거
    } else {
        break;                   // 더 이상 연산 불가능
    }
    count++;
}
```

### ⏰ 시간복잡도

- **시간복잡도:** O(log2의 N) <= T(n) = k(log2의N + log10의N), while 정지 조건에 의해 start 값은 고정값, last는 가변값이므로 last를 중심으로 생각, k번 반복
- **공간복잡도:** O(1) => 뭘까
- last를 2로 나누거나 10으로 나누는 연산이므로 로그 시간에 해결

## 🚀 문제 2: 주유소 (13305번)

### 📖 문제 설명

N개 도시를 연결하는 도로가 있고, 각 도시마다 주유소가 있어서 기름을 넣을 수 있습니다.
왼쪽 도시에서 오른쪽 도시로 가는 최소 비용을 구하는 문제입니다.

**입력:**

- N (2 ≤ N ≤ 100,000) => int 범위 내
- 도시 간 거리 배열
- 각 도시의 주유 가격 배열

**출력:** 최소 주유 비용 => long으로 출력

### 💡 풀이 아이디어

- 일단 다음 주유소까지 충전함.
- 다음 주유소의 가격과 현재위치의 주유소의 가격을 비교
- 더 싼 주유소가 나올 때 까지 탐색
- 거리를 고려해서 가장 싼 주요소 가격 \* 거리 해서 계산후 sum 에 저장 후 출력

### 🔍 핵심 로직

```java
long leastCost = cost[0];  // 첫 번째 도시 가격으로 시작
long sum = 0;
for (int i = 0; i < dist.length; i++) {
    if (leastCost > cost[i]) {
        leastCost = cost[i];    // 더 싼 가격 발견시 갱신
    }
    sum += leastCost * dist[i]; // 현재 최소 가격으로 주유
}
```

### ⏰ 시간복잡도

- **시간복잡도:** O(N)
- **공간복잡도:** O(N) => ? 뭐지
- 도시 수만큼 한 번씩 순회하므로 선형 시간

## 🚀 문제 3: 피로도 (22864번)

### 📖 문제 설명

하루 24시간 동안 일할 수 있는 최대 일량을 구하는 문제입니다.

**피로도 시스템:**

- 일할 때: 피로도 +A, 일량 +B
- 쉴 때: 피로도 -C (0 이하로는 내려가지 않음)
- 피로도가 M을 초과하면 일할 수 없음

**입력:** A, B, C, M (1 ≤ A, B, C, M ≤ 1,000,000) => int
**출력:** 24시간 동안 할 수 있는 최대 일량 => int

### 💡 풀이 아이디어

- 피로도가 최대가 아니라고 무조건 일하면 리미트M를 넘어가는 경우가 생기므로<br>
  일할때 쌓이는 피로도 A를 여유분으로 생각해서 현재 피로도의 합과 합쳐서 이 경우에 해당하는<br>
  피로도 리미트 M과 같거나 작은경우에만 일하고 나머지경우에는 피로도 리미트가 오버되는 경우이므로<br>
  회복 매커니즘을 C을 실행.

### 🔍 핵심 로직

```java
for (int hour = 1; hour <= 24; hour++) {
    if (tired + a <= m) {           // 피로도가 허용 범위
        work += b;                   // 일하기
        tired += a;                  // 피로도 증가
    } else {
        tired = Math.max(0, tired - c); // 쉬기 (피로도 감소)
    }
}
```

## 🔗 관련 링크

- [백준 16953번 - A → B](https://www.acmicpc.net/problem/16953)
- [백준 13305번 - 주유소](https://www.acmicpc.net/problem/13305)
- [백준 22864번 - 피로도](https://www.acmicpc.net/problem/22864)
