/**
 * 백준 22864번 - 피로도 [그리드 알고리즘]
 *
 * [문제 요약]
 * - 하루에 한 시간 단위로 일을 하거나 일을 쉴 수 있다
 * - 하루에 한 시간 일하면 피로도는 A만큼 쌓이고 일은 B만큼 처리 가능
 * - 한 시간을 쉬면 피로도는 C만큼 줄어듬
 * - 피로도가 음수로 내려가면 0으로 바뀜, 쉬면 당연히 처리한 일은 없음
 * - 피로도를 최대한 M을 넘지 않게 일을 하려고 함, M을 넘기면 번아웃이 와 이미 했던 일들도 던지고 일 그만둠
 * - 피로관리하면서 하루에 최대로 일할 수 있는 경우를 구하자 (하루는 24시간)
 *
 * [해결 방법]
 * - 24시간 만큼 루프를 돌도록 설정
 * - 현재 피로도에 한 시간 피로도를 더했을 때, 한계를 넘는지 체크
 * - 넘는 경우, 휴식을 부여해 현재 피로도에서 C만큼 차감(단 음수가 되는 경우, 0으로 설정)
 * - 넘지 않는 경우, 일을 하여 일처리량 증가
 * - 단, 애초에 한계 피로도보다 한시간 피로도가 더 높은 경우 바로 0을 반환
 *
 * [시간 복잡도]
 * - 24시간 루프 -> O(n)
 * - 전체 시간 복잡도 -> O(n)
 */

public class Main {

    static int solve(int a, int b, int c, int m) {
        int work = 0;
        int piro = 0;

        // 한 시간 일하면 바로 한계 초과라면 불가능
        if (a > m) return 0;

        for (int i = 0; i < 24; i++) {
            if (piro + a > m) {
                // 휴식
                piro -= c;
                if (piro < 0) piro = 0;
            } else {
                // 일 수행
                work += b;
                piro += a;
            }
        }

        return work;
    }

    public static void main(String[] args) {
        // 테스트 케이스 1
        int a1 = 3, b1 = 4, c1 = 2, m1 = 10;
        System.out.println("Test1 max work: " + solve(a1, b1, c1, m1)); // 기대값 출력

        // 테스트 케이스 2
        int a2 = 5, b2 = 3, c2 = 1, m2 = 20;
        System.out.println("Test2 max work: " + solve(a2, b2, c2, m2)); // 기대값 출력
    }
}