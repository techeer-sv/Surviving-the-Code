# Week 2

Created on 2025-08-27

## 22864.js 문제 풀이과정 및 시간복잡도

### 풀이과정

- 네 개의 정수 A(일할 때 증가하는 피로도), B(일할 때 처리하는 일의 양), C(쉴 때 감소하는 피로도), M(최대 피로도)를 입력받는다.
- 하루는 24시간이므로, 24번 반복한다.
- 매 시간마다 현재 피로도(tired)에 A를 더했을 때 M 이하라면 일을 하고, 피로도와 일의 양을 각각 증가시킨다.
- 만약 일을 할 수 없다면(피로도 + A > M), 한 시간 쉰다. 이때 피로도를 C만큼 감소시키고, 음수가 되면 0으로 맞춘다.
- 24시간 동안 위 과정을 반복한 뒤, 총 처리한 일(work)을 출력한다.

### 시간복잡도

- 반복문은 24번(고정) 실행되므로 O(1) (상수 시간복잡도)이다.
- 입력 파싱도 O(1)이다.
- 전체 알고리즘의 시간복잡도는 O(1)이다.

## 13305.js 문제 풀이과정 및 시간복잡도

### 풀이과정

- 첫 번째 줄에 도시의 개수 N, 두 번째 줄에 인접한 도시를 연결하는 도로의 길이(N-1개), 세 번째 줄에 각 도시의 주유소 리터당 가격(N개)이 주어진다.
- 출발 도시부터 도착 도시까지 이동하면서, **지금까지 만난 가장 싼 주유소 가격**으로 다음 도시까지의 거리를 이동하는 것이 최소 비용이 된다.
- 첫 번째 도시의 가격을 minPrice로 설정하고, 각 도시를 돌면서 현재 도시의 가격이 minPrice보다 더 싸면 minPrice를 갱신한다.
- 각 구간마다 minPrice와 해당 구간의 거리를 곱해서 total에 누적한다.
- 마지막 도시는 더 이상 이동할 거리가 없으므로, N-1번만 반복한다.
- 최종적으로 누적된 total을 출력한다.

### 시간복잡도

- 입력 파싱: O(N)
- 한 번의 for문으로 N-1개의 구간을 순회하므로 O(N)
- 전체 알고리즘의 시간복잡도는 **O(N)** 이다.
